<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frontend on Frank Wang&#39;s Coding World</title>
    <link>http://www.wangxingfeng.com/categories/frontend/index.xml</link>
    <description>Recent content in Frontend on Frank Wang&#39;s Coding World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>[Frank Wang](//www.wangxingfeng.com). Powered by [Hugo](//gohugo.io). Theme by [PPOffice](http://github.com/ppoffice).</copyright>
    <atom:link href="http://www.wangxingfeng.com/categories/frontend/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何用CSS代码实现网页设计中的菱形图片</title>
      <link>http://www.wangxingfeng.com/diamond-picture.html</link>
      <pubDate>Mon, 01 May 2017 22:00:03 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/diamond-picture.html</guid>
      <description>

&lt;p&gt;在网页设计中，我们常常能够看到被裁切成菱形的图片。&lt;/p&gt;

&lt;p&gt;传统的实现方式是预先在图像处理软件中把图片裁切好，当然这种方式的可维护性差。&lt;/p&gt;

&lt;p&gt;而现在，随着CSS的新特性的支持度越来越好了，CSS也越来越强大，我们已经可以用CSS代码来实现菱形图片了。&lt;/p&gt;

&lt;h2 id=&#34;1-基于tranform的实现方法&#34;&gt;1. 基于tranform的实现方法&lt;/h2&gt;

&lt;p&gt;原图
&lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; style=&#34;display:block; max-width: 200px; margin:0 auto&#34;&gt;
用一个&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 把图片包裹起来，对这个容器&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;应用&lt;code&gt;transform:rotate(45deg)&lt;/code&gt;, 进行旋转45度，我们得到如下的效果：图片应该也会跟着旋转了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div{
    width:200px;
    transform: rotate(45deg);
    overflow: hidden;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;diamond-pic&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; &gt;
&lt;/div&gt;

&lt;p&gt;如果我们对里面的图片进行反向旋转45度，那么图片的旋转就会抵消掉。看看效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;img{
    max-width:100%;
    transform: rotate(-45deg);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;diamond-pic&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; class=&#34;diamond-img&#34;&gt;
&lt;/div&gt;

&lt;p&gt;我们得到了一个裁成&lt;code&gt;八边形&lt;/code&gt;的图片。&lt;/p&gt;

&lt;p&gt;问题出在哪里呢？我给外面的&lt;code&gt;div&lt;/code&gt;加一个边框，这样就容易看出来了。&lt;/p&gt;

&lt;div class=&#34;diamond-pic&#34; style=&#34;border:1px solid red&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; class=&#34;diamond-img&#34;&gt;
&lt;/div&gt;

&lt;p&gt;问题出在了这里图片的宽度是与容器&lt;code&gt;div&lt;/code&gt;的&lt;code&gt;边长&lt;/code&gt;相等，其实我们应该让图片的宽度与&lt;code&gt;对角线&lt;/code&gt;相等。&lt;/p&gt;

&lt;p&gt;运用勾股定理，可以计算出图片的宽度应该是√2倍，我们取1.42倍。&lt;/p&gt;

&lt;p&gt;如果通过&lt;code&gt;width属性&lt;/code&gt;设置来放大图片,会得到如下的效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;img{
    max-width:142%;
    transform: rotate(-45deg);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;diamond-pic&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; class=&#34;diamond-img&#34; style=&#34;max-width:142%;&#34;&gt;
&lt;/div&gt;

&lt;p&gt;因为是以图片的&lt;code&gt;左上角&lt;/code&gt;为原点进行放大的。我们还需要在通过设置&lt;code&gt;margin:-45px;&lt;/code&gt;才能得到菱形图片。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;img{
    max-width:142%;
    transform: rotate(-45deg);
    margin:-45px;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;diamond-pic&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; class=&#34;diamond-img&#34; style=&#34;max-width:142%; margin:-45px&#34;&gt;
&lt;/div&gt;

&lt;p&gt;当然，我们可以通过&lt;code&gt;transform:scale(1.42)&lt;/code&gt;来放大图片1.42倍。&lt;code&gt;scale()&lt;/code&gt;是以图片的&lt;code&gt;中心点&lt;/code&gt;进行缩放的，这样我们就不用额外地设置&lt;code&gt;margin&lt;/code&gt;值了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div&amp;gt;img{
    max-width:100%;
    transform: scale(1.42) rotate(-45deg);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;diamond-pic&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adamcatlace.jpg&#34; class=&#34;diamond-img&#34; style=&#34;transform: rotate(-45deg) scale(1.42);&#34;&gt;
&lt;/div&gt;

&lt;h2 id=&#34;2-基于裁切路径clip-path方法&#34;&gt;2. 基于裁切路径clip-path方法&lt;/h2&gt;

&lt;p&gt;第一种方法虽然可以奏效，但存在一些缺点：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.需要一层额外的HTML标签；
2.代码不够直观；
3.如果处理的图片不是正方形，将无法得到一个菱形图片，如下图所示：
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;diamond-pic&#34;&gt;
    &lt;img src=&#34;http://csssecrets.io/images/adam-sleeping.jpg&#34; class=&#34;diamond-img&#34; style=&#34;transform: rotate(-45deg) scale(1.42);&#34;&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code&gt;SVG&lt;/code&gt;中，有个名叫&lt;code&gt;&amp;lt;clipPath&amp;gt;&lt;/code&gt;的元素，专门用来定义剪裁路径。其实CSS中也有一个类似的属性，即&lt;code&gt;clip-path属性&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;clip-path&lt;/code&gt;可以把元素裁切成我们想要的任何形状。我们通过&lt;code&gt;polygon()函数&lt;/code&gt;来指定一个菱形，参数是一系列用&lt;code&gt;逗号&lt;/code&gt;分隔的&lt;code&gt;坐标点&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;img{
    clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://csssecrets.io/images/adam-sleeping.jpg&#34; class=&#34;diamon-pic-clip-path&#34; &gt;&lt;/p&gt;

&lt;p&gt;如上图所示，这个方法可以很好的适应非正方形的图片。&lt;/p&gt;

&lt;p&gt;另外，因为&lt;code&gt;clip-path&lt;/code&gt;属性可以参与动画，我们还可以给这个图片动画过渡效果。比如，当我们的鼠标悬停到图片上时，菱形图片平滑地扩展为完整的原图。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;img{
    clip-path: polygon(50% 0, 100% 50%, 50% 100%, 0 50%);
    transition: 1s clip-path;
}
img:hover{
    clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://csssecrets.io/images/adam-sleeping.jpg&#34; class=&#34;diamon-pic-clip-path-2&#34; &gt;&lt;/p&gt;

&lt;p&gt;注意，除了谷歌浏览器，其他浏览器对这个clip-path属性的支持度都还不是很好。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用CSS创建内容不倾斜的平行四边形</title>
      <link>http://www.wangxingfeng.com/parallelograms.html</link>
      <pubDate>Sun, 30 Apr 2017 16:44:06 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/parallelograms.html</guid>
      <description>

&lt;h2 id=&#34;1-平行四边形&#34;&gt;1.平行四边形&lt;/h2&gt;

&lt;p&gt;普通的网页元素是矩形的。但有时候，我们需要创建可以传达出一种动感的形状，比如平行四边形。&lt;/p&gt;

&lt;p&gt;说到&lt;code&gt;倾斜&lt;/code&gt;，我们会想到使用&lt;code&gt;transform&lt;/code&gt;属性的&lt;code&gt;skew()&lt;/code&gt;方法来对普通的矩形元素进行&lt;code&gt;斜向拉伸&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:100px;
height:60px;
transform: skew(-30deg);
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&#34;width:100px;height:60px;margin:10px auto;color:#fff;background: #673ab7;font-size: 16px;line-height: 60px;text-align: center;transform: skew(-30deg);&#34;&gt;平行四边形&lt;/div&gt;

&lt;p&gt;如上所示，我们得到了一个平行四边形，但是内容也跟着斜向变形了。我们希望只是容器倾斜，而内容是不倾斜的。怎么办？&lt;/p&gt;

&lt;h2 id=&#34;2-嵌套元素方案&#34;&gt;2.嵌套元素方案&lt;/h2&gt;

&lt;p&gt;首先，我们可以先在容器内部新增一个元素，包裹里面的内容，对这个元素再次进行斜向变形，值为负的外面容器的斜向变形值，这样刚好可以抵消掉斜向变形。&lt;/p&gt;

&lt;p&gt;HTML代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;parallelograms-container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;parallelograms-inner&amp;quot;&amp;gt;
        平行四边形
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.parallelograms-container{
    width:100px;
    height:60px;
    transform: skew(-30deg);
}

.parallelograms-inner{
    transform:skew(30deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;parallelograms-container&#34;&gt;
    &lt;div class=&#34;parallelograms-inner&#34;&gt;
        平行四边形
    &lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&#34;3-伪元素方案&#34;&gt;3.伪元素方案&lt;/h2&gt;

&lt;p&gt;如果我们不想添加额外的HTML结构，能否用纯CSS来实现呢？&lt;/p&gt;

&lt;p&gt;答案是肯定的。&lt;/p&gt;

&lt;p&gt;我们可以考虑用CSS生成&lt;code&gt;伪元素&lt;/code&gt;，然后把所有样式（背景、边框等）应用到伪元素上，用&lt;code&gt;绝对定位&lt;/code&gt;将伪元素重叠在内容之下，然后再对伪元素进行&lt;code&gt;斜向拉伸&lt;/code&gt;变形。这样内容就可以保持不倾斜。&lt;/p&gt;

&lt;p&gt;HTML 代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;pseudo-container&amp;quot;&amp;gt;
    平行四边形
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS 代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.pseudo-container{
    position:relative;
    /* 内容的文字大小、颜色、内边距等样式在这里*/
    width:100px;
    height:60px;
    margin:0 auto;
    color:#fff;
    font-size: 16px;
    line-height: 60px;
    text-align: center;
    background:transparent;
}

.pseudo-container::before{
    content:&amp;quot;&amp;quot;;
    position:absolute;
    top:0;right:0;bottom:0;left:0;
    z-index:-1;
    background: #673ab7;
    transform: skew(-30deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果如下：
&lt;div class=&#34;pseudo-container&#34;&gt;
    平行四边形
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意这里有个小坑。由于我们对这个伪元素设置了&lt;code&gt;z-index:-1&lt;/code&gt;, 所以，必须确保这个伪元素的容器、以及容器的&lt;code&gt;祖先元素&lt;/code&gt;(一直追溯到&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;的&lt;code&gt;直接子元素&lt;/code&gt;)的背景都必须是透明的，否则将会遮盖住这个&lt;code&gt;伪元素&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用CSS绘制椭圆、半椭圆、四分之一椭圆</title>
      <link>http://www.wangxingfeng.com/ellipse-border-radius.html</link>
      <pubDate>Sun, 30 Apr 2017 11:25:58 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/ellipse-border-radius.html</guid>
      <description>

&lt;h2 id=&#34;1-border-radius&#34;&gt;1.border-radius&lt;/h2&gt;

&lt;p&gt;border-radius可以为元素添加圆角边框，比如 按钮。&lt;/p&gt;

&lt;p&gt;&lt;button style=&#34;display:block; width:160px; height:60px; margin:10px auto;color:#fff;background: #ff5722; border-radius:8px; border:none;outline:none; &#34;&gt;
    示例按钮
&lt;/button&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-兼容性-ie9-以上都很好地能够兼容border-radius&#34;&gt;2.兼容性： IE9+以上都很好地能够兼容border-radius。&lt;/h2&gt;

&lt;h2 id=&#34;3-border-radius绘制圆形&#34;&gt;3.border-radius绘制圆形&lt;/h2&gt;

&lt;p&gt;如果我们给一个正方形的元素设置一个足够大的border-radius值（只要大于等于正方形边长的一半）的话，就可以被这个元素变成圆形。
但考虑到元素的高宽可能不是固定的，那么，我们可以设置百分比，这个百分比是基于元素的尺寸大小来解析的。当我们给一个正方形的元素设置border-radius：50%时，我们会得到一个自适应的圆形。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:200px;
height:200px;
border-radius:50%; /*在这里等价于border-radius:100px; 建议写成百分比*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示：
&lt;div style=&#34;width:200px; height:200px; border-radius: 50%; background: #03a9f4; margin: 10px auto&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-border-radius绘制自适应椭圆&#34;&gt;4.border-radius绘制自适应椭圆&lt;/h2&gt;

&lt;p&gt;当元素的高宽不相等时，我们来看下会变成什么样子。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:300px; /*宽度变长了*/
height:200px;
border-radius:50%; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如下所示：
&lt;div style=&#34;width:300px; height:200px; border-radius: 50%; background: #cddc39; margin: 10px auto&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，当元素的高宽不相等，border-radius设置为50%，我们将会得到一个自适应的椭圆。&lt;/p&gt;

&lt;h2 id=&#34;5-border-radius绘制半个椭圆&#34;&gt;5.border-radius绘制半个椭圆&lt;/h2&gt;

&lt;p&gt;如果想要得到半个椭圆，怎么办呢？&lt;/p&gt;

&lt;div style=&#34;width:300px; height:100px; border-radius: 50% / 100% 100% 0 0; background: #795548; margin: 10px auto&#34;&gt;&lt;/div&gt;

&lt;p&gt;我们需要补充以下两个知识点：&lt;/p&gt;

&lt;p&gt;1.border-radius的值是可以单独指定水平方向上的半径和垂直方向上的半径的，中间需要用一个斜杠(/)分隔开两个值。&lt;/p&gt;

&lt;p&gt;2.border-radius是一个简写属性，我们可以单独为元素的每个角指定不同的值。border-radius展开的话是以下4个属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;border-top-left-radius
border-top-right-radius
border-bottom-right-radius
border-bottom-left-radius
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们不必分开写，可以给border-radius指定4个值，用空格分开。浏览器解析的时候，是按顺时针顺序应用到元素的四个角的（和margin、padding等其他的常见属性的简写类似）。&lt;/p&gt;

&lt;p&gt;我们来分析一下这个半椭圆形。&lt;/p&gt;

&lt;p&gt;1.它是垂直对称的，说明左上角和右上角的半径值是相同的；左下角和右下角的半径值也应该是相同的。&lt;/p&gt;

&lt;p&gt;2.它的顶部边缘是曲线的，说明左上角和右上角的半径值之和应该是等于这个元素的宽的。&lt;/p&gt;

&lt;p&gt;3.由前面两点可以推出，左上角和右上角的半径在水平方向上是50%。&lt;/p&gt;

&lt;p&gt;4.再看垂直方向上，顶部的两个圆角占据了整个元素的高度，而底部完全没有任何圆角。因此，可以推断左上角和右上角的半径在垂直方向上是100%，左下角和右下角在垂直方向上是0。&lt;/p&gt;

&lt;p&gt;综上所述，&lt;code&gt;border-radius&lt;/code&gt;的值应该是&lt;code&gt;50% / 100% 100% 0 0&lt;/code&gt;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:300px;
height:100px;
border-radius: 50% / 100% 100% 0 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&#34;width:300px; height:100px; border-radius: 50% / 100% 100% 0 0; background: #795548; margin: 10px auto&#34;&gt;&lt;/div&gt;

&lt;p&gt;如果我们把垂直方向上的值改为0 0 100% 100%，则可以得到另一个半椭圆。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:300px;
height:100px;
border-radius: 50% /0 0 100% 100% ;
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&#34;width:300px; height:100px; border-radius: 50% / 0 0 100% 100%; background: #4caf50; margin: 10px auto&#34;&gt;&lt;/div&gt;

&lt;p&gt;如果把&lt;code&gt;水平方向&lt;/code&gt;&lt;code&gt;border-raduis&lt;/code&gt;设置为&lt;code&gt;50%&lt;/code&gt;; &lt;code&gt;垂直方向&lt;/code&gt;上，左上角和左下角设置为&lt;code&gt;100%&lt;/code&gt;； 右上角和右下角设为&lt;code&gt;0&lt;/code&gt;，则可以得到一个&lt;code&gt;沿Y轴劈开的半椭圆形&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:150px;
height:200px;
border-radius: 100% 0 0 100% / 50%;
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&#34;width:150px; height:200px; border-radius: 100% 0 0 100% / 50% ; background: #9c27b0; margin: 10px auto&#34;&gt;&lt;/div&gt;

&lt;h2 id=&#34;6-border-radius绘制椭圆的四分之一&#34;&gt;6.border-radius绘制椭圆的四分之一&lt;/h2&gt;

&lt;p&gt;如果想要得到四分之一个椭圆呢？顺着之前的思路，我们可以设置其中一个角的&lt;code&gt;border-radius&lt;/code&gt;值为&lt;code&gt;100%&lt;/code&gt;，其他三个角为&lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;width:150px;
height:100px;
border-radius: 100% 0 0 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;div style=&#34;width:150px; height:100px; border-radius: 100% 0 0 0 ; background: #9e9e9e; margin: 10px auto&#34;&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>用CSS实现图片翻转的动画效果</title>
      <link>http://www.wangxingfeng.com/css-flip.html</link>
      <pubDate>Sat, 29 Apr 2017 21:24:00 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/css-flip.html</guid>
      <description>

&lt;h2 id=&#34;用css实现页面或图片翻转的动画效果&#34;&gt;用CSS实现页面或图片翻转的动画效果&lt;/h2&gt;

&lt;p&gt;Web开发中常常会有动画的交互效果，以前我们只能用JavaScript来实现，随着浏览器对CSS3新特性的支持度越来越好，很多的特效都可以通过CSS代码来实现。&lt;/p&gt;

&lt;p&gt;我们在浏览网站的时候，经常能够看到图片会翻转的动画效果，比如&lt;code&gt;Demo 1&lt;/code&gt;所示。&lt;/p&gt;

&lt;div class=&#34;rotate-container&#34; style=&#34;border:2px solid #000;&#34;&gt;
    &lt;div class=&#34;flipper&#34;&gt;
        &lt;div class=&#34;front&#34;&gt;
            &lt;!-- 前面内容 --&gt;
            &lt;p &gt;正面内容&lt;/p&gt;
            &lt;img src=&#34;https://images-cn.ssl-images-amazon.com/images/I/51fD0ZgQoXL._SL400_.jpg&#34; alt=&#34;&#34;&gt;
        &lt;/div&gt;
        &lt;div class=&#34;back&#34;&gt;
            &lt;p&gt;反面内容&lt;/p&gt;
            &lt;img src=&#34;https://images-cn.ssl-images-amazon.com/images/G/28/kindle/merch/2014/campaign/Gen7-Launch/Associate/Associate_AssociateCenrter_300_250_Family._V325383366_.jpg&#34; alt=&#34;&#34;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;能否用纯CSS来实现这种翻转动画效果呢？答案是肯定的。&lt;/p&gt;

&lt;p&gt;我们知道CSS3的&lt;code&gt;transform&lt;/code&gt;属性非常强大，可以实现2D或者3D的旋转、缩放、移动或倾斜。&lt;/p&gt;

&lt;p&gt;上述Demo1是沿着Y轴3D翻转的，我们可以想到用&lt;code&gt;transform&lt;/code&gt;属性的&lt;code&gt;rotateY()&lt;/code&gt;方法来实现。&lt;/p&gt;

&lt;h2 id=&#34;示例代码&#34;&gt;示例代码&lt;/h2&gt;

&lt;p&gt;HTML代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;rotate-container&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;flipper&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;front&amp;quot;&amp;gt;
            &amp;lt;!-- 前面内容 --&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&amp;quot;back&amp;quot;&amp;gt;
            &amp;lt;!-- 背面内容 --&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.rotate-container:hover .flipper{
    transform: rotateY(180deg);
}

.rotate-container, .front, .back {
    width: 320px;
    height: 480px;
}

.flipper {
    transition-duration: 1s;  
    transform-style: preserve-3d;
    position: relative;
}

.front, .back {
    backface-visibility: hidden;
    position: absolute;
    top: 0;
    left: 0;
}

.front {
    z-index: 2;
}

.back {
    transform: rotateY(180deg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关键的技术点解释&#34;&gt;关键的技术点解释：&lt;/h2&gt;

&lt;h3 id=&#34;1-transform-变形&#34;&gt;1.transform：变形&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;transform: rotateY(180deg)&lt;/code&gt; 表示沿着Y轴旋转180度。
&lt;style&gt;
    .rotateY{
        transition-duration:1.5s;
    }
    .rotateY45:hover{
        transform: rotateY(45deg);
    }
    .rotateY90:hover{
        transform: rotateY(90deg);
    }
    .rotateY180:hover{
        transform: rotateY(180deg);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
.bf-hidden{
    transform-style: preserve-3d;
    backface-visibility: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/style&gt;
&lt;p&gt;Demo2：沿着Y轴旋转180度(旋转到背面可见)&lt;/p&gt;
&lt;div class=&#34;rotateY rotateY180&#34;&gt;
    &lt;img src=&#34;https://images-cn.ssl-images-amazon.com/images/I/51fD0ZgQoXL._SL400_.jpg&#34; alt=&#34;&#34;&gt;
&lt;/div&gt;
&lt;p&gt;Demo3：沿着Y轴旋转90度&lt;/p&gt;
&lt;div class=&#34;rotateY rotateY90&#34;&gt;
    &lt;img src=&#34;https://images-cn.ssl-images-amazon.com/images/I/51fD0ZgQoXL._SL400_.jpg&#34; alt=&#34;&#34;&gt;
&lt;/div&gt;
&lt;p&gt;Demo4：沿着Y轴旋转45度&lt;/p&gt;
&lt;div class=&#34;rotateY rotateY45&#34;&gt;
    &lt;img src=&#34;https://images-cn.ssl-images-amazon.com/images/I/51fD0ZgQoXL._SL400_.jpg&#34; alt=&#34;&#34;&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-transform-style-指定该元素的子元素所在空间&#34;&gt;2.transform-style：指定该元素的子元素所在空间。&lt;/h3&gt;

&lt;p&gt;指定该元素的子元素是（看起来）位于三维空间内，还是在该元素所在的平面内被扁平化。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transform-style&lt;/code&gt;属性有两个参数，&lt;code&gt;flat&lt;/code&gt;和&lt;code&gt;preserve-3d&lt;/code&gt;。&lt;code&gt;flat&lt;/code&gt;为默认值，指定子元素位于此元素所在平面内; &lt;code&gt;preserve-3d&lt;/code&gt;指定子元素定位在三维空间内。&lt;/p&gt;

&lt;h3 id=&#34;3-backface-visibility-指定元素旋转到背面时是否可见&#34;&gt;3.backface-visibility 指定元素旋转到背面时是否可见。&lt;/h3&gt;

&lt;p&gt;默认为visible，即背面是可见的, 如&lt;code&gt;Demo2&lt;/code&gt;所示。&lt;/p&gt;

&lt;p&gt;在Demo1中，由于翻转过来的是另外一张图片，所以设置为backface-visibility:hidden背面是不可见的。&lt;/p&gt;

&lt;p&gt;&lt;p&gt;Demo5: 沿着Y轴旋转180度(旋转到背面不可见)&lt;/p&gt;
&lt;div class=&#34;rotate-container&#34;&gt;
    &lt;div class=&#34;flipper&#34; &gt;
        &lt;div class=&#34;front&#34;&gt;
            &lt;img src=&#34;https://images-cn.ssl-images-amazon.com/images/I/51fD0ZgQoXL._SL400_.jpg&#34; alt=&#34;&#34;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-transition-duration-表示完成过渡效果需要花费的时间&#34;&gt;4.transition-duration：表示完成过渡效果需要花费的时间。&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;transition-duration：1s&lt;/code&gt;可以用简写的形式&lt;code&gt;transition:1s&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;5-position-absolute-绝对定位&#34;&gt;5.position:absolute：绝对定位。&lt;/h3&gt;

&lt;p&gt;使用绝对定位&lt;code&gt;position:absolute&lt;/code&gt;把翻转前后的两个元素摆放到同一个位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS预处理器之Less</title>
      <link>http://www.wangxingfeng.com/less.html</link>
      <pubDate>Sun, 23 Apr 2017 16:28:38 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/less.html</guid>
      <description>

&lt;h2 id=&#34;1-css&#34;&gt;1.CSS&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;CSS&lt;/code&gt;层叠样式表(Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。&lt;/p&gt;

&lt;p&gt;由于&lt;code&gt;CSS&lt;/code&gt;不想普通的编程语言有自己的变量、常量、条件语句、函数等编程语法，而只是一行行单纯的属性描述，所以写起来相当的费事，代码难以组织和维护。&lt;/p&gt;

&lt;h2 id=&#34;2-dry&#34;&gt;2.DRY&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;DRY&lt;/code&gt;, 即 Don&amp;rsquo;t Repeat Yourself， 是一种为程序员所熟悉的编程理念，优秀的程序员通常遵循这种规范编写代码。
&lt;code&gt;DRY&lt;/code&gt;可以显著地提升代码的可维护性，比如在需要改变某个参数的时候，只需要改动一处或者少数几处地方。&lt;/p&gt;

&lt;h2 id=&#34;3-css预处理器&#34;&gt;3.CSS预处理器&lt;/h2&gt;

&lt;p&gt;纯粹的&lt;code&gt;CSS&lt;/code&gt;代码并没有变量、嵌套、条件等概念，难以做到DRY, 这令程序员们头痛不已。因此，有程序员尝试为 &lt;code&gt;CSS&lt;/code&gt; 增加一些编程的的特性，使得在 &lt;code&gt;CSS&lt;/code&gt; 中使用变量、简单的程序逻辑、函数成为可能。&lt;/p&gt;

&lt;p&gt;目前，最常用的CSS预处理器，主要有3个：&lt;code&gt;Less&lt;/code&gt;、&lt;code&gt;SASS&lt;/code&gt;、&lt;code&gt;Stylus&lt;/code&gt;。
从&lt;a href=&#34;https://github.com/showcases/css-preprocessors&#34;&gt;GitHub&lt;/a&gt;上可以看出&lt;code&gt;Less&lt;/code&gt;是最受欢迎的&lt;code&gt;CSS&lt;/code&gt;预处理器。
&lt;img src=&#34;http://www.wangxingfeng.com/images/2017042301.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-less&#34;&gt;3.Less&lt;/h2&gt;

&lt;h3 id=&#34;3-1-安装&#34;&gt;3.1 安装&lt;/h3&gt;

&lt;p&gt;因为&lt;code&gt;Less&lt;/code&gt;是使用&lt;code&gt;JavaScript&lt;/code&gt;语言写的，它可以运行在服务端的&lt;code&gt;NodeJS&lt;/code&gt;环境中，因此，最简单的安装方式是用 &lt;code&gt;npm install&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g less # -g表示全局安装
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-编译&#34;&gt;3.2 编译&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Less&lt;/code&gt;文件的后缀名为&lt;code&gt;.less&lt;/code&gt;. 浏览器并不能直接识别&lt;code&gt;.less&lt;/code&gt;的文件，需要编译成&lt;code&gt;.css&lt;/code&gt;结尾的&lt;code&gt;CSS&lt;/code&gt;样式文件。
假设你已经有一个&lt;code&gt;less&lt;/code&gt;文件&lt;code&gt;demo.less&lt;/code&gt;，在命令行执行以下命令，即可编译生成&lt;code&gt;demo.css&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lessc demo.less demo.css  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;lessc&lt;/code&gt;是Less的命令，第一个参数demo.less为指定需要编译的源文件名， 第二个参数demo.css为编译后的CSS文件名。&lt;/p&gt;

&lt;p&gt;如果需要编译成压缩的CSS文件，可以全局安装下载一个Less官方提供的插件 &lt;a href=&#34;https://github.com/less/less-plugin-clean-css&#34;&gt;clean-css plugin&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install -g less-plugin-clean-css
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，在命令行输入如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lessc --clean-css demo.less demo.min.css #多了一个参数 --clean-css
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-基本语法&#34;&gt;3.3 基本语法&lt;/h3&gt;

&lt;h4 id=&#34;3-3-1-变量&#34;&gt;3.3.1 变量&lt;/h4&gt;

&lt;p&gt;Less 的变量名使用&lt;code&gt;@&lt;/code&gt;符号开始, 比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;

#header {
  color: @light-blue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译之后，得到如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#header {
  color: #6c94be;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：Less的变量本质上是常量，只能定义 一次。&lt;/p&gt;

&lt;h4 id=&#34;3-3-2-mixins&#34;&gt;3.3.2 Mixins&lt;/h4&gt;

&lt;p&gt;将一系列属性从一个规则集引入(“混合”)到另一个规则集的方式。&lt;/p&gt;

&lt;p&gt;比如，先定义了一个规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要在其他的地方使用到这个规则，可以这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#menu a {
  color: #111;
  .bordered;
}

.post a {
  color: red;
  .bordered;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
#menu a {
  color: #111;
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
.post a {
  color: red;
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-3-嵌套&#34;&gt;3.3.3 嵌套&lt;/h4&gt;

&lt;p&gt;根据HTML结构来嵌套样式规则。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#header {
  color: black;
  .navigation {
    font-size: 12px;
  }
  .logo {
    width: 300px;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译之后的CSS样式文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#header {
  color: black;
}
#header .navigation {
  font-size: 12px;
}
#header .logo {
  width: 300px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以结合伪类来嵌套，比如“清除浮动”的样式可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.clearfix {
  display: block;
  zoom: 1;

  &amp;amp;:after {
    content: &amp;quot; &amp;quot;;
    display: block;
    font-size: 0;
    height: 0;
    clear: both;
    visibility: hidden;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码里的符号&lt;code&gt;&amp;amp;&lt;/code&gt;表示当前选择器的父选择器。&lt;/p&gt;

&lt;p&gt;编译之后的结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.clearfix {
  display: block;
  zoom: 1;
}
.clearfix:after {
  content: &amp;quot; &amp;quot;;
  display: block;
  font-size: 0;
  height: 0;
  clear: both;
  visibility: hidden;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-4-媒体查询及嵌套&#34;&gt;3.3.4 媒体查询及嵌套&lt;/h4&gt;

&lt;p&gt;媒体查询（Media query ）可以嵌套在选择器中，编译时，会自动把选择器复制到媒体查询体内。媒体查询规则里还可以嵌套媒体查询。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.screen-color {
  @media screen {
    color: green;
    @media (min-width: 768px) {
      color: red;
    }
  }
  @media tv {
    color: black;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@media screen {
  .screen-color {
    color: green;
  }
}
@media screen and (min-width: 768px) {
  .screen-color {
    color: red;
  }
}
@media tv {
  .screen-color {
    color: black;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-5-运算&#34;&gt;3.3.5 运算&lt;/h4&gt;

&lt;p&gt;在Less中，数值、颜色、变量可以进行加、减、乘、除的运算。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@color: #224488 / 2; //results in #112244
background-color: #112244 + #111; // result is #223355

@base: 5%;
@filler: @base * 2; // result is 10%
@other: @base + @filler; // result is 15%
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-6-函数&#34;&gt;3.3.6 函数&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Less&lt;/code&gt;提供了许多用于转换颜色、处理字符串 以及进行算术运算的函数。具体可以参考&lt;a href=&#34;http://lesscss.org/functions/&#34;&gt;Less Function Reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这些函数使用起来非常简单。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@base: #f04615;
@width: 0.5;

.class {
  width: percentage(@width); 
  color: saturate(@base, 5%);
  background-color: spin(lighten(@base, 25%), 8);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述代码中我们使用 函数&lt;code&gt;percentage()&lt;/code&gt; 将 0.5 转换为 50%，然后用 函数&lt;code&gt;saturate()&lt;/code&gt;将基础颜色值的饱和度增加了 5%，再使用 函数lighten() 将背景颜色的亮度增加了 25%，最后通过函数spin()又将色相值增加 8。编译之后：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class {
  width: 50%;
  color: #f6430f;
  background-color: #f8b38d;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-5-官网&#34;&gt;3.5 官网&lt;/h3&gt;

&lt;p&gt;更多内容，可以访问&lt;a href=&#34;http://lesscss.org/&#34;&gt;http://lesscss.org/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ES6的块级作用域以及let、const命令</title>
      <link>http://www.wangxingfeng.com/es6-let-const</link>
      <pubDate>Fri, 07 Apr 2017 20:18:56 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/es6-let-const</guid>
      <description>

&lt;h2 id=&#34;1-块级作用域&#34;&gt;1.块级作用域&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ES5&lt;/code&gt; 只有&lt;code&gt;全局作用域&lt;/code&gt;和&lt;code&gt;函数作用域&lt;/code&gt;，没有&lt;code&gt;块级作用域&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在函数外部声明的变量，都是全局变量，容易导致变量冲突。因此，我们不得不使用&lt;code&gt;立即执行函数&lt;/code&gt;来避免全局变量的冲突。另外，在循环内用来计数的变量也会泄露成全局变量。&lt;/p&gt;

&lt;p&gt;为此，&lt;code&gt;ES6&lt;/code&gt; 引入了&lt;code&gt;块级作用域&lt;/code&gt;的概念。&lt;/p&gt;

&lt;h2 id=&#34;2-let-声明变量&#34;&gt;2.&lt;code&gt;let&lt;/code&gt; 声明变量&lt;/h2&gt;

&lt;p&gt;2.1 &lt;code&gt;let&lt;/code&gt;声明的变量，只在它所在的代码块（块级作用域）内有效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    var a = 1;
    let b = 2;
}
a //1 
b // Uncaught ReferenceError: b is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2 &lt;code&gt;for循环&lt;/code&gt;的计数器使用&lt;code&gt;let&lt;/code&gt;命令来声明。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 10; i++) {
    //
}
console.log(i);  //ReferenceError: i is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.3 不存在&lt;code&gt;变量提升&lt;/code&gt;。变量应该遵循&lt;code&gt;先声明后使用&lt;/code&gt;的原则。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;var&lt;/code&gt;声明的变量会提升到作用域的顶部,在变量可以在声明之前可以使用，值为&lt;code&gt;undefined&lt;/code&gt;。&lt;code&gt;let&lt;/code&gt;声明的变量不存在&lt;code&gt;变量提升&lt;/code&gt;, 声明之前使用，会报错。&lt;/p&gt;

&lt;p&gt;2.4 暂时性死区(temporal dead zone，简称 TDZ):&lt;/p&gt;

&lt;p&gt;只要&lt;code&gt;块级作用域&lt;/code&gt;内存在&lt;code&gt;let命令&lt;/code&gt;，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。在let命令声明该变量之前的区域内，该变量不能使用，即使外部声明了该变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let a = 1;
if (true) {
    // TDZ开始
    console.log(a); //Uncaught ReferenceError: a is not defined

    let a;  //TDZ结束
}

let b = 1;
if (true) {
    let b = 100; 
    console.log(b);  //100
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以这么理解暂时性死区：只要一进入当前的块级作用域，所有将要使用的变量就已经存在了，但是还暂时无法获取，只有等到声明变量之后，才可以获取和使用该变量。&lt;/p&gt;

&lt;p&gt;2.5 不能重复声明变量&lt;/p&gt;

&lt;p&gt;在同一个作用域内，&lt;code&gt;let&lt;/code&gt;命令不能重复声明同一个变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function () {
    let x = 10;
    var x = 20;
}
// Uncaught SyntaxError: Identifier &#39;x&#39; has already been declared
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-const-声明常量&#34;&gt;3.&lt;code&gt;const&lt;/code&gt; 声明常量&lt;/h2&gt;

&lt;p&gt;3.1 &lt;code&gt;ES6&lt;/code&gt; 引入了&lt;code&gt;常量&lt;/code&gt;的概念。&lt;code&gt;const 命令&lt;/code&gt;是用来声明&lt;code&gt;常量&lt;/code&gt;的, 通常用&lt;code&gt;大写字母&lt;/code&gt;表示常量。一旦声明，常量的值就不能改变。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const PI = 3.1415;
PI = 3; //Uncaught TypeError: Assignment to constant variable.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.2 `声明变量时，必须立即赋值。否则会报错。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const SIN //Uncaught SyntaxError: Missing initializer in const declaration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.3 &lt;code&gt;const&lt;/code&gt;的作用域与&lt;code&gt;let&lt;/code&gt;命令相同：常量只在它声明时所在的&lt;code&gt;块级作用域&lt;/code&gt;内有效。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (true) {
  const A = 5;
}
A // Uncaught ReferenceError: A is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.4 &lt;code&gt;const&lt;/code&gt;命令声明的常量也是不提升，同样存在&lt;code&gt;暂时性死区&lt;/code&gt;，只能在声明的位置后面使用。同时，也不能重复声明。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript数组的常用方法总结</title>
      <link>http://www.wangxingfeng.com/js-array</link>
      <pubDate>Thu, 06 Apr 2017 22:31:32 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/js-array</guid>
      <description>

&lt;h2 id=&#34;不改变原数组的方法&#34;&gt;不改变原数组的方法：&lt;/h2&gt;

&lt;p&gt;1.&lt;code&gt;indexOf()&lt;/code&gt; 和&lt;code&gt;lastIndexOf()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;1.1 &lt;code&gt;indexOf()&lt;/code&gt; : 返回元素在数组的索引，从&lt;code&gt;0&lt;/code&gt;开始。若数组不存在该元素，则返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2];
arr.indexOf(1); //0
arr.indexOf(10); //-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.2 &lt;code&gt;lastIndexOf()&lt;/code&gt;:
返回元素在数组中最后一次出现的索引，如果没有出现则返回-1.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3, 4, 2];
arr.lastIndexOf(2); // 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;code&gt;slice()&lt;/code&gt;: 与&lt;code&gt;字符串&lt;/code&gt;的&lt;code&gt;substring()&lt;/code&gt;方法一样，截取数组的一部分，返回一个新的数组。&lt;/p&gt;

&lt;p&gt;2.1 通常，接受2个参数作为一个左闭右开区间，即包括开始索引位置的元素，但不包括结束索引位置的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3,4,5,6];
arr.slice(0,2)    //[1, 2] 只返回索引0,1位置的元素
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2 可以省略第二个参数，即截取到原数组的最后一个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.slice(2,);    //[3, 4, 5, 6] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.3 如果没有传参数，则返回一个从头到尾截取所有元素的新数组。可以用来复制一个数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var copyArr = arr.slice();
copyArr;   //[1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.&lt;code&gt;concat()&lt;/code&gt;: 合并数组。把当前的数组和另一个数组连接起来，并返回一个新的数组。&lt;/p&gt;

&lt;p&gt;3.1 &lt;code&gt;concat()&lt;/code&gt;方法的参数可以有多个，也可以任意任意类型，&lt;code&gt;数值&lt;/code&gt;、&lt;code&gt;字符串&lt;/code&gt;、&lt;code&gt;布尔值&lt;/code&gt;、&lt;code&gt;数组&lt;/code&gt;、&lt;code&gt;对象&lt;/code&gt; 都可以，参数会被被添加到新的数组中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr1 =  [1, 2, 3,4,5,6];
var arr2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];
var arr3 = arr1.concat(arr2);
arr3;   //[1, 2, 3, 4, 5, 6, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.2 注意，如果参数是&lt;code&gt;数组&lt;/code&gt;, 会被拉平一次，即数组会被拆开来，加入到新的数组中。具体看示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr1 = [1, 2, 3];
var arr2 = arr1.concat(66,&#39;abc&#39;,true,[10,20],[30,[31,32]],{x:100});
arr2;  //[1, 2, 3, 66, &amp;quot;abc&amp;quot;, true, 10, 20, 30, [31,32], {x:100}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;code&gt;join()&lt;/code&gt;: 转成字符串。它会把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串。&lt;/p&gt;

&lt;p&gt;4.1 参数是用来指定连接的字符串。见示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.join(&#39;*&#39;)   //&amp;quot;1*2*3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.2 如果没有指定参数，默认是用&lt;code&gt;,&lt;/code&gt;连接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.join()   //&amp;quot;1,2,3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;toString()&lt;/code&gt;: 返回数组的字符串形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.toString() // &amp;quot;1,2,3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.&lt;code&gt;valueOf()&lt;/code&gt;:返回数组本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.valueOf() // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.&lt;code&gt;map()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;7.1 对数组的所有成员&lt;code&gt;依次调用一个函数&lt;/code&gt;，返回值是一个新数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
arr.map(function(elem){
    return elem*2;
});
//[2, 4, 6, 8]
arr; //[1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.2 &lt;code&gt;map&lt;/code&gt;方法接受一个函数作为参数,该函数调用时，map方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.map(function(elem, index, arr) {
    return elem * index;
}); 
//[0, 2, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.3 &lt;code&gt;map&lt;/code&gt;方法还可以接受第2个参数，表示回调函数执行时&lt;code&gt;this&lt;/code&gt;所指向的对象。&lt;/p&gt;

&lt;p&gt;8.&lt;code&gt;forEach()&lt;/code&gt;: 与map方法很相似，也是遍历数组的所有成员，执行某种操作。&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;forEach&lt;/code&gt;方法一般没有返回值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3];
function log(element, index, array) {
    console.log(&#39;[&#39; + index + &#39;] = &#39; + element);
}
arr.forEach(log);
// [0] = 1
// [1] = 2
// [2] = 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: &lt;code&gt;forEach&lt;/code&gt;方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用&lt;code&gt;for循环&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;9.&lt;code&gt;filter()&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;9.1 筛选数组的元素，返回值是符合筛选条件元素组成的一个新数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3, 4, 5];
arr.filter(function (elem) {
  return (elem &amp;gt; 3);
});
//[4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.2 &lt;code&gt;filter&lt;/code&gt;方法接受一个函数作为参数,该函数调用时，&lt;code&gt;fitler&lt;/code&gt;方法会将其传入3个参数，分别是当前成员、当前位置和数组本身(后2个参数可选)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3, 4, 5];
arr.filter(function (elem, index, arr) {
  return index % 2 === 1;
});
//[2, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.3 &lt;code&gt;filter&lt;/code&gt;方法还可以接受第2个参数，指定测试函数所在的&lt;code&gt;上下文对象&lt;/code&gt;（即&lt;code&gt;this对象&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;10.&lt;code&gt;some()&lt;/code&gt;和&lt;code&gt;every()&lt;/code&gt;: 类似“断言”（assert），用来判断数组成员是否符合某种条件。&lt;/p&gt;

&lt;p&gt;10.1 接受一个函数作为参数，所有数组成员依次执行该函数，返回一个&lt;code&gt;布尔值&lt;/code&gt;。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。&lt;/p&gt;

&lt;p&gt;10.2 &lt;code&gt;some&lt;/code&gt;方法是只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3, 4];
arr.some(function (elem, index, arr) {
  return elem &amp;gt;= 3;
});
// true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.3 &lt;code&gt;every&lt;/code&gt;方法则是所有数组成员的返回值都是true，才返回true，否则false。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 3, 4];
arr.every(function (elem, index, arr) {
  return elem &amp;gt;= 3;
});
// false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.4 注意，对于&lt;code&gt;空数组&lt;/code&gt;，&lt;code&gt;some&lt;/code&gt;方法返回false，&lt;code&gt;every&lt;/code&gt;方法返回true&lt;/p&gt;

&lt;p&gt;10.5 &lt;code&gt;some&lt;/code&gt;和&lt;code&gt;every&lt;/code&gt;方法还可以接受第2个参数，用来绑定函数中的&lt;code&gt;this关键字&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;11.&lt;code&gt;reduce()&lt;/code&gt;和&lt;code&gt;reduceRight()&lt;/code&gt;: 依次处理数组的每个成员，最终累计为一个值。&lt;/p&gt;

&lt;p&gt;11.1&lt;code&gt;reduce&lt;/code&gt;是&lt;code&gt;从左到右&lt;/code&gt;处理（从第一个成员到最后一个成员）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.reduce(function(x, y){
  console.log(x, y)
  return x + y;
});
// 1 2
// 3 3
// 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.2&lt;code&gt;reduceRight&lt;/code&gt;则是&lt;code&gt;从右到左&lt;/code&gt;处理（从最后一个成员到第一个成员）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.reduceRight(function(x, y){
  console.log(x, y)
  return x + y;
});
// 3 2
// 5 1
// 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;改变原数组的方法&#34;&gt;改变原数组的方法：&lt;/h2&gt;

&lt;p&gt;1.&lt;code&gt;push()&lt;/code&gt;: 向数组的末尾添加若干元素。返回值是改变后的数组长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2];
arr.push(3) ;// 3
arr; //  [1, 2, 3]
arr.push(&#39;b&#39;,&#39;c&#39;); //5
arr; //[1, 2, 3, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
arr.push([10,20]); //6
arr; //[1, 2, 3, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, [10,20]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.&lt;code&gt;pop()&lt;/code&gt;: 删除数组最后一个元素。返回值是删除的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr =[1, 2, 3, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, [10,20]];
arr.pop(); //[10, 20]
arr;  // [1, 2, 3, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.&lt;code&gt;unshift()&lt;/code&gt;: 向数组头部添加若干元素。返回值是改变后的数组长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2];
arr.unshift(3,4 );  //4
arr;  // [3, 4, 1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.&lt;code&gt;shift()&lt;/code&gt;: 删除数组最后一个元素。返回值是删除的元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&#39;a&#39;, &#39;b&#39;, 1, 2];
arr.shift(); //&#39;a&#39;
arr;  //[&#39;b&#39;, 1, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.&lt;code&gt;sort()&lt;/code&gt;: 数组排序。&lt;/p&gt;

&lt;p&gt;5.1 &lt;strong&gt;注意&lt;/strong&gt;：默认是将所有元素转换成&lt;code&gt;字符串&lt;/code&gt;，再按&lt;code&gt;字符串Unicode码点&lt;/code&gt;排序。返回值是新的数组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 12, &#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;A&#39;, &#39;B&#39;]
arr.sort();  //[1, 12, 2, &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;ab&amp;quot;, &amp;quot;b&amp;quot;] 注意：12排在了2的前面
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.2 如果元素都是&lt;code&gt;数字&lt;/code&gt;，要按&lt;code&gt;从小到大&lt;/code&gt;排序，可以传入一个回调函数作为参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 12, 100]

arr.sort(function(a,b){
    return a-b;
});
// [1, 2, 12, 100]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.3 如果想要&lt;code&gt;从大到小&lt;/code&gt;排序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.sort(function(a,b){
    return b-a;
});
//[100, 12, 2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.&lt;code&gt;reverse()&lt;/code&gt;: 颠倒数组中元素的位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1, 2, 12, &#39;a&#39;, &#39;b&#39;, &#39;ab&#39;, &#39;A&#39;, &#39;B&#39;];
arr.reverse();
//[&amp;quot;B&amp;quot;, &amp;quot;A&amp;quot;, &amp;quot;ab&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;, 12, 2, 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.&lt;code&gt;splice()&lt;/code&gt;: 修改数组元素（新增、删减、替换）。从&lt;code&gt;指定的索引&lt;/code&gt;开始删除&lt;code&gt;若干个&lt;/code&gt;元素，然后再从该位置添加&lt;code&gt;若干个元素&lt;/code&gt;。返回值是删除的元素组成的数组。参数1是删除元素的起始索引，参数2是删除的元素个数，之后的参数为待添加的元素。&lt;/p&gt;

&lt;p&gt;7.1 只删除,不添加。可以传入2个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [&#39;Alibaba&#39;, &#39;Tencent&#39;, &#39;Baidu&#39;, &#39;XiaoMi&#39;, &#39;360&#39;];

// 从索引2开始删除3个元素
arr.splice(2, 3); // 返回删除的元素 [&#39;Baidu&#39;, &#39;XiaoMi&#39;, &#39;360&#39;]
arr; // [&#39;Alibaba&#39;, &#39;Tencent&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.2 只添加,不删除。第2个参数设为&lt;code&gt;0&lt;/code&gt;，即不删除元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;arr.splice(2, 0, &#39;Toutiao&#39;, &#39;Meituan&#39;, &#39;Didi&#39;); // 返回[],因为没有删除任何元素
arr; //[&amp;quot;Alibaba&amp;quot;, &amp;quot;Tencent&amp;quot;, &amp;quot;Toutiao&amp;quot;, &amp;quot;Meituan&amp;quot;, &amp;quot;Didi&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7.3 先删除若干元素，然后在删除的位置上在添加若干个元素。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var  arr =[&amp;quot;Alibaba&amp;quot;, &amp;quot;Tencent&amp;quot;, &amp;quot;Toutiao&amp;quot;, &amp;quot;Meituan&amp;quot;, &amp;quot;Didi&amp;quot;]
arr.splice(2,2,&#39;Apple&#39;,&#39;Google&#39;);  //[&amp;quot;Toutiao&amp;quot;, &amp;quot;Meituan&amp;quot;]
arr; //[&amp;quot;Alibaba&amp;quot;, &amp;quot;Tencent&amp;quot;, &amp;quot;Apple&amp;quot;, &amp;quot;Google&amp;quot;, &amp;quot;Didi&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;array-isarray&#34;&gt;&lt;code&gt;Array.isArray()&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;用来判断一个值是否为数组, 如果参数为数组，返回true，否则，返回false.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = [1,2]
Array.isArray(arr);  //true;

Array.isArray(&#39;a&#39;); //false
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript实现复制内容到剪贴板的功能</title>
      <link>http://www.wangxingfeng.com/copy2clipboard</link>
      <pubDate>Wed, 05 Apr 2017 20:29:51 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/copy2clipboard</guid>
      <description>

&lt;h2 id=&#34;1-zeroclipboard-js&#34;&gt;1.ZeroClipboard.js&lt;/h2&gt;

&lt;p&gt;点击按钮实现复制链接或者一段文本到剪贴板，这个小功能想必不少人都见过。GitHub上就有这么一个点击按钮复制仓库地址的功能。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.wangxingfeng.com/images/2017040501.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Github&lt;/code&gt;用的是&lt;a href=&#34;http://zeroclipboard.org/&#34;&gt;ZeroClipboard&lt;/a&gt;来实现这一功能。这个库是用一个不可见的Flash来完成剪贴操作的。即将 Flash 做成透明的，以便于我们放在诸如链接、按钮等需要放置的任何地方。这样，用户界面看起来没有变化，当点击链接或按钮时，实际上点击是却是 Flash，从而实现复制操作。具体实现方法，可以参考官方文档&lt;a href=&#34;http://zeroclipboard.org。&#34;&gt;http://zeroclipboard.org。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我们知道&lt;code&gt;Flash&lt;/code&gt;正走向没落，不少功能被越来越强大的&lt;code&gt;HTML5&lt;/code&gt;所替代。而且，出于安全方面的考虑，不少浏览器都默认禁用了Flash。那么有没有不是Flash的实现方式呢？&lt;/p&gt;

&lt;h2 id=&#34;2-clipboard-js&#34;&gt;2.clipboard.js&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://clipboardjs.com/&#34;&gt;clipboard.js&lt;/a&gt;是个更加轻量的JavaScript库，没有使用Flash，而是依赖于&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Selection&#34;&gt;Selection&lt;/a&gt;和&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand&#34;&gt;execCommand&lt;/a&gt;这两个API，并且使用了HTML5的特性，比如自定义数据的&lt;code&gt;data-* 属性&lt;/code&gt;。因此，clipboard.js在兼容性方面比ZeroClipboard.js差，但现代浏览器(IE9+)基本能够兼容。&lt;/p&gt;

&lt;p&gt;使用方法非常简单：&lt;/p&gt;

&lt;p&gt;1)&lt;a href=&#34;https://github.com/zenorocha/clipboard.js/archive/master.zip&#34;&gt;下载代码&lt;/a&gt;，并引入到文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;dist/clipboard.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)实例化一个Clipboard对象，参数可以是&lt;code&gt;CSS选择器&lt;/code&gt;、&lt;code&gt;HTML节点&lt;/code&gt;、NodeList对象&lt;/p&gt;

&lt;p&gt;参数为&lt;code&gt;CSS选择器&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Clipboard(&#39;.btn&#39;); // btn为DOM元素的class名, 跟jQuery的用法一样。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数为&lt;code&gt;HTML节点&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var btn = document.getElementById(&#39;btn&#39;);
var clipboard = new Clipboard(btn);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数为&lt;code&gt;NodeList对象&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var btns = document.querySelectorAll(&#39;button&#39;);
var clipboard = new Clipboard(btns);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3)实例化对象的时候，可以同时设置复制的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var clipboard = new Clipboard(&#39;.btn&#39;, {
    text: function() {
        return &#39;to be or not to be&#39;; //剪贴板上的文本
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4)也可以通过data-*属性来设置要复制的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- Target --&amp;gt;
&amp;lt;input id=&amp;quot;foo&amp;quot; value=&amp;quot;https://github.com/zenorocha/clipboard.js.git&amp;quot;&amp;gt;

&amp;lt;!-- Trigger --&amp;gt;
&amp;lt;button class=&amp;quot;btn&amp;quot; data-clipboard-target=&amp;quot;#foo&amp;quot;&amp;gt;点击复制&amp;lt;/button&amp;gt;

&amp;lt;script&amp;gt;
    var clipboard = new Clipboard(&#39;.btn&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击一下，看看是否成功复制到剪贴板：&lt;/p&gt;

&lt;p&gt;&lt;input id=&#34;foo&#34; value=&#34;https://github.com/zenorocha/clipboard.js.git&#34; style=&#34;width:300px;&#34;&gt;
&lt;button class=&#34;btn&#34; data-clipboard-target=&#34;#foo&#34;&gt;点击复制&lt;/button&gt;
&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.6.0/clipboard.min.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;script type=&#34;text/javascript&#34; &gt;
    var clipboard = new Clipboard(&#39;.btn&#39;);
&lt;/script&gt;

&lt;p&gt;&lt;code&gt;data-clipboard-target&lt;/code&gt;属性的值&lt;code&gt;#foo&lt;/code&gt;对应的是目标节点的CSS选择器。&lt;/p&gt;

&lt;p&gt;5）更多的配置信息和使用方法，请查阅&lt;a href=&#34;https://clipboardjs.com/&#34;&gt;clipboard.js官网&lt;/a&gt;，有兴趣的朋友，应该看看它的源码。&lt;/p&gt;

&lt;p&gt;注意我说的看源码，指的是&lt;code&gt;src目录&lt;/code&gt;的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.wangxingfeng.com/images/2017040502.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.wangxingfeng.com/images/2017040505.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;代码是长这样的。没错，这是ES6的写法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.wangxingfeng.com/images/2017040504.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;千万不要去看&lt;code&gt;dist&lt;/code&gt;下的&lt;code&gt;clipboard.js&lt;/code&gt; ，那个是编译之后的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.wangxingfeng.com/images/2017040503.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>通过userAgent识别移动设备，自动跳转移动端站点</title>
      <link>http://www.wangxingfeng.com/useragent</link>
      <pubDate>Tue, 04 Apr 2017 21:02:50 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/useragent</guid>
      <description>

&lt;p&gt;不少互联网公司的网站都分为PC端和手机端。如果用户用手机访问PC站点，受限于手机网络，很可能会出现加载网页缓慢的情况。
因此，如何识别用户访问网站的设备，并且自动跳转到对应的站点呢？&lt;/p&gt;

&lt;h2 id=&#34;navigator-useragent&#34;&gt;navigator.userAgent&lt;/h2&gt;

&lt;p&gt;navigator是JavaScript中的一个独立的对象，用于提供用户所使用的浏览器以及操作系统等信息，以navigator对象属性的形式来提供。所有浏览器都支持该对象。&lt;/p&gt;

&lt;p&gt;navigator对象有一个userAgent属性，会返回用户的设备操作系统和浏览器的信息。&lt;/p&gt;

&lt;p&gt;1.用&lt;code&gt;谷歌浏览器&lt;/code&gt;，随便打开一个网页，&lt;code&gt;F12&lt;/code&gt;打开Chrome调试工具，输入&lt;code&gt;navigator.userAgent&lt;/code&gt;, 会返回如下的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个字符串可以分成四个主要的部分，我来解释一下各个部分的含义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）Mozilla/5.0 ：表示兼容Mozilla, 几乎所有的浏览器都有这个字符;
2) (Windows NT 6.1; Win64; x64): 表示设备的操作系统版本，以及CPU信息；
3）AppleWebKit/537.36 (KHTML, like Gecko)：表示浏览器的内核；
4) Chrome/57.0.2987.98 Safari/537.36: 表示浏览器的版本号。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.用&lt;code&gt;火狐浏览器&lt;/code&gt;，随便打开一个网页，&lt;code&gt;F12&lt;/code&gt;打开调试工具，同样地在控制台输入&lt;code&gt;navigator.userAgent&lt;/code&gt;, 返回如下的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;与之前的结果区别：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1)浏览器内核是Gecko内核，
2)浏览器版本是火狐的Firefox/52.0。从这里我们可以看出火狐浏览器是基于Gecko内核。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.用&lt;code&gt;谷歌浏览器&lt;/code&gt;模拟&lt;code&gt;手机&lt;/code&gt;访问，选择&lt;code&gt;iPhone6s&lt;/code&gt;，同样在调试工具控制台输入&lt;code&gt;navigator.userAgent&lt;/code&gt;, 会返回如下的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意看出现了&lt;code&gt;iPhone&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;4.用&lt;code&gt;谷歌浏览器&lt;/code&gt;模拟&lt;code&gt;平板设备&lt;/code&gt;访问，选择&lt;code&gt;iPad&lt;/code&gt;，同样在调试工具控制台输入&lt;code&gt;navigator.userAgent&lt;/code&gt;, 会返回如下的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Mozilla/5.0 (iPad; CPU OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意看出现了&lt;code&gt;iPad&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;5.用&lt;code&gt;谷歌浏览器&lt;/code&gt;模拟&lt;code&gt;安卓设备&lt;/code&gt;，比如选择&lt;code&gt;Galaxy S5&lt;/code&gt;，同样在调试工具控制台输入&lt;code&gt;navigator.userAgent&lt;/code&gt;, 会返回如下的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Mobile Safari/537.36&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意看出现了&lt;code&gt;Android&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;6.用&lt;code&gt;谷歌浏览器&lt;/code&gt;模拟&lt;code&gt;winPhone设备&lt;/code&gt;，比如选择&lt;code&gt;Microsoft Lumia 950&lt;/code&gt;，同样在调试工具控制台输入&lt;code&gt;navigator.userAgent&lt;/code&gt;, 会返回如下的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意看出现了&lt;code&gt;Windows Phone&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过以上的小测试，我们还可以能够发现一个规律：手机和平板设备访问时，&lt;code&gt;navigator.userAgent&lt;/code&gt;返回的字符串都会包含&lt;code&gt;Mobile&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;useragent的用途-识别手机-平板设备&#34;&gt;userAgent的用途：识别手机、平板设备&lt;/h2&gt;

&lt;p&gt;刚才我们已经看到了手机和平板设备访问时，&lt;code&gt;navigator.userAgent&lt;/code&gt;返回的字符串都会包含&lt;code&gt;Mobile&lt;/code&gt;，可以利用这一点，来实现文章开头提出的需求，自动识别用户访问设备从而跳转对应的站点。&lt;/p&gt;

&lt;p&gt;PC端站点可以加上如下代码，自动跳转到移动端站点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ua = navigator.userAgent.toLowerCase();
if (/mobile|android|iphone|ipad|phone/i.test(ua)) {
   window.location.href = &amp;quot;http://m.example.com&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果在&lt;code&gt;微信&lt;/code&gt;中打开和在&lt;code&gt;手机浏览器&lt;/code&gt;打开网页执行的是不同的脚本的话，还可以通过&lt;code&gt;userAgent&lt;/code&gt;来判断是否是在&lt;code&gt;微信&lt;/code&gt;中打开的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var ua = navigator.userAgent.toLowerCase();
if(/micromessenger/i.test(ua){
    //to do
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本文首发于&lt;a href=&#34;http://www.wangxingfeng.com/&#34;&gt;Frank Wang的个人博客&lt;/a&gt;, 转载时请附上原文链接。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>代码换行导致的inline元素间距bug</title>
      <link>http://www.wangxingfeng.com/fix-inline-bug</link>
      <pubDate>Wed, 11 Jan 2017 21:48:19 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/fix-inline-bug</guid>
      <description>

&lt;h2 id=&#34;inline-元素&#34;&gt;inline 元素：&lt;/h2&gt;

&lt;p&gt;如果inline元素(span, strong, b, em, i等)代码换行，它们之间会产生我们不希望的间隔。通过设置&lt;code&gt;margin:0&lt;/code&gt;或者&lt;code&gt;padding:0&lt;/code&gt; , 这个都间隔仍然存在，说明这个间隔并不是margin或者padding。&lt;/p&gt;

&lt;style type=&#34;text/css&#34;&gt;
    .inline p span:first-child {
        background-color: #66d9ef;
    }
    .inline p span:nth-child(2) {
        background-color: #c191c1;
    }
    .inline p span:nth-child(3) {
        background-color: #9fe89f;
    }
    .inline p span:nth-child(4) {
        background-color: #8787f1;
    }
    .inline p span:last-child{
        background-color: #464141;
    }
    .inline p span{
        font-size:16px;
        color:#fff;
        line-height:30px;
    }

    .inline-block span{
        display: inline-block;
        width:20%;
    }
    .fs0{
        font-size: 0;
    }
&lt;/style&gt;

&lt;div class=&#34;inline &#34;&gt;
    &lt;p&gt;
        &lt;span&gt;inline元素 1&lt;/span&gt;
        &lt;span&gt;inline元素 2&lt;/span&gt;
        &lt;span&gt;inline元素 3&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;是否为了不消除这个间隔，就必须把inline元素的html代码写在一行内呢？答案是否定的。
开发的时候，为了方便阅读和调试，我们习惯于把代码写成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
    &amp;lt;span&amp;gt;inline元素 1&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;inline元素 2&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;inline元素 3&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;inline元素 4&amp;lt;/span&amp;gt;
    &amp;lt;span&amp;gt;inline元素 5&amp;lt;/span&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决方法：设置父元素&lt;code&gt;font-size:0&lt;/code&gt;，再给子元素单独设置&lt;code&gt;font-size&lt;/code&gt;，修复bug。
&lt;div class=&#34;inline &#34;&gt;
    &lt;p class=&#34;fs0&#34;&gt;
        &lt;span&gt;inline元素 1&lt;/span&gt;
        &lt;span&gt;inline元素 2&lt;/span&gt;
        &lt;span&gt;inline元素 3&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;h2 id=&#34;inline-block-元素&#34;&gt;inline-block 元素：&lt;/h2&gt;

&lt;p&gt;要在一行展示多个并列的元素，除了通过设置浮动&lt;code&gt;float:left;float:right&lt;/code&gt;，我们还可以通过设置&lt;code&gt;display:inline-block&lt;/code&gt; 把inline元素或block元素，转换成一个可以设置高度和宽度的inline-block元素。&lt;/p&gt;

&lt;p&gt;如果有5个&lt;code&gt;inline-block&lt;/code&gt;元素，设置它们的宽度为&lt;code&gt;20%&lt;/code&gt;。我们期望它们是在一行展示的。但是因为html代码换行产生了间距，导致无法在一行内显示。
&lt;div class=&#34;inline &#34;&gt;
    &lt;p class=&#34;inline-block&#34;&gt;
        &lt;span&gt;inline-block元素 1&lt;/span&gt;
        &lt;span&gt;inline-block元素 2&lt;/span&gt;
        &lt;span&gt;inline-block元素 3&lt;/span&gt;
        &lt;span&gt;inline-block元素 4&lt;/span&gt;
        &lt;span&gt;inline-block元素 5&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;
解决方法: 设置父元素&lt;code&gt;font-size:0&lt;/code&gt;，再给子元素单独设置&lt;code&gt;font-size&lt;/code&gt;。
&lt;div class=&#34;inline &#34;&gt;
    &lt;p class=&#34;inline-block fs0&#34;&gt;
        &lt;span&gt;inline-block元素 1&lt;/span&gt;
        &lt;span&gt;inline-block元素 2&lt;/span&gt;
        &lt;span&gt;inline-block元素 3&lt;/span&gt;
        &lt;span&gt;inline-block元素 4&lt;/span&gt;
        &lt;span&gt;inline-block元素 5&lt;/span&gt;
    &lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript的正则表达式</title>
      <link>http://www.wangxingfeng.com/js-reg</link>
      <pubDate>Sun, 18 Dec 2016 21:56:37 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/js-reg</guid>
      <description>

&lt;h2 id=&#34;1-基本概念&#34;&gt;1.基本概念&lt;/h2&gt;

&lt;p&gt;正则表达式(&lt;code&gt;Regular Expression&lt;/code&gt;)是一个字符串，定义了某个规则，按照这种规则来描述、匹配一系列符合条件的字符串。&lt;/p&gt;

&lt;h2 id=&#34;2-通配符&#34;&gt;2.通配符&lt;/h2&gt;

&lt;p&gt;当前目录下查找文件(linux 命令行)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find ./ -name *.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-在线图形工具&#34;&gt;3.在线图形工具：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://regexper.com/&#34;&gt;https://regexper.com/&lt;/a&gt; 是一款非常实用的正则表达式图形化工具。你也可以&lt;a href=&#34;https://regexper.com/&#34;&gt;下载&lt;/a&gt;到本地，运行速度更快&lt;/p&gt;

&lt;h2 id=&#34;4-ide中可以支持正则表达式&#34;&gt;4.IDE中可以支持正则表达式：&lt;/h2&gt;

&lt;p&gt;我用的是编辑器是&lt;code&gt;Sublime Text 3&lt;/code&gt;。快捷键&lt;code&gt;Ctrl+F&lt;/code&gt;查找字符串，&lt;code&gt;Ctrl+H&lt;/code&gt;替换字符串，在底部唤出的面板左上角有开启正则表达式（快捷键&lt;code&gt;Alt+R&lt;/code&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://www.wangxingfeng.com
http://m.wangxingfeng.com
http://cosmic.wangxingfeng.com
http://blog.wangxingfeng.com
http://img.wangxingfeng.com/1234.jpg
http://img.wangxingfeng.com/158.png
https://img.wangxingfeng.com/128744.jpg
http://img.wangxingfeng.com/1285.jpg
http://img.wangxingfeng.com/7884.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Sublime&lt;/code&gt;中找出上面的&lt;code&gt;url&lt;/code&gt;中&lt;code&gt;http&lt;/code&gt;协议的&lt;code&gt;jpg&lt;/code&gt;文件，去掉其协议头&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Find What: http:\/\/(.+\.jpg)
replace with: $1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-javascript中实例化-regexp-对象&#34;&gt;5.JavaScript中实例化&lt;code&gt;RegExp&lt;/code&gt;对象&lt;/h2&gt;

&lt;p&gt;5.1.字面量:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg = /\d/; 
var reg2 = /[a-zA-Z0-9]/g;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.2.构造函数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg = new RegExp(\d); 
var reg = new RegExp(&#39;[a-zA-Z0-9]&#39;, &#39;g&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-修饰符&#34;&gt;6.修饰符：&lt;/h2&gt;

&lt;p&gt;6.1.&lt;code&gt;g&lt;/code&gt;(global):表示全局匹配，不添加则默认匹配到第一个字符串。&lt;/p&gt;

&lt;p&gt;6.2.&lt;code&gt;i&lt;/code&gt;(ignore case):表示忽略大小写,不添加则默认大小写敏感。&lt;/p&gt;

&lt;p&gt;6.3.&lt;code&gt;m&lt;/code&gt;(multiple lines):表示多行匹配。&lt;/p&gt;

&lt;h2 id=&#34;7-原意文本字符-和元字符&#34;&gt;7.原意文本字符 和元字符：&lt;/h2&gt;

&lt;p&gt;7.1.原意文本字符：表示字符的原本含义，如&lt;code&gt;a&lt;/code&gt;表示小写字母a，&lt;code&gt;1&lt;/code&gt;表示数字1。&lt;/p&gt;

&lt;p&gt;7.2.元字符：在正则表达式中有特殊含义的非字母字符，如星号&lt;code&gt;*&lt;/code&gt;，问号&lt;code&gt;？&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;7.3.常用元字符及其含义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1）[]:构建字符类，范围类等；
2）{}:量词，表示字符的个数；
3）():构建分组；
4）*：表示任意个字符；可理解为{0,}；
5）？：表示最多有一个该字符{0,1}；
6）+：表示至少有一个该字符{1,}；
7）^: 取反；
8）\n: 换行符；
9）\r: 回车符；
10）\0: 空字符；
11）\t: 水平制表符；
12）\v:  垂直制表符；
13）\f: 换页符。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-字符类&#34;&gt;8.字符类：&lt;/h2&gt;

&lt;p&gt;8.1.通常，正则表达式一个字符对应字符串一个字符，如&lt;code&gt;/a/&lt;/code&gt;对应字母a。元字符&lt;code&gt;[]&lt;/code&gt;构建一个字符类，如&lt;code&gt;[abc]&lt;/code&gt;可以匹配字符a或b或c中的任意一个。在浏览器调试界面控制台输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;a1b2c3d4a&#39;.match(/[abc]/g);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到匹配的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;a&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.2字符类取反：&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;[]&lt;/code&gt;内使用元字符^创建反向类，即匹配不属于某个字符类的字符串。如&lt;code&gt;[^abc]&lt;/code&gt;匹配不是字符a、b、c的内容。
在浏览器调试界面控制台输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;a1b2c3d4a&#39;.match(/[^abc]/g);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到匹配的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;4&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.3范围类：&lt;/p&gt;

&lt;p&gt;1)&lt;code&gt;[a-z]&lt;/code&gt;表示：a到z的任意一个字符；&lt;/p&gt;

&lt;p&gt;在浏览器调试界面控制台输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;a1b2c3d4a&#39;.match(/[a-z]/g);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到匹配的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;a&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)&lt;code&gt;[a-zA-Z]&lt;/code&gt;表示：a到z以及A到Z的任意一个字符。&lt;/p&gt;

&lt;p&gt;在浏览器调试界面控制台输入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;a1B2Zc3d4&#39;.match(/[a-zA-Z]/g);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会得到匹配的字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[&amp;quot;a&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;Z&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8.4 预定义类（简写）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1) /./ =&amp;gt; /[^\r\n]/  除了回车符和换行符之外的任何字符
2) /\d/ =&amp;gt; [0-9]  数字字符
3) /\D/ =&amp;gt; [^0-9] 非数字字符
4) /\s/ =&amp;gt; 空白字符
5) /\S/ =&amp;gt; 非空白字符
6) /\w/ =&amp;gt; [a-zA-Z0-9_]单词字符（字母，数字，下划线. 
7) /\W/ =&amp;gt; [^a-zA-Z0-9_]非单词字符
8) \b: 单词边界
9) \B：非单词边界；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9.量词：在字符后跟一个{}表示重复前面字符的次数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.) /\d{1,20}/: 1~20个数字；
2.) /\d*/ =&amp;gt; /\d{0,}/: 任意个数字;
3.) /\d+/ =&amp;gt; /\d{1,}/  :至少一个数字；
4.) /\d?/ =&amp;gt; /\d{0,1}/ :之多一个数字；
5.) /\d{3}/ : 3个数字
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-贪婪模式与非贪婪模式&#34;&gt;10.贪婪模式与非贪婪模式：&lt;/h2&gt;

&lt;p&gt;10.1.贪婪模式：正则表达式会尽可能多地去匹配字符。&lt;/p&gt;

&lt;p&gt;例如，下面的正则表达式，匹配3到6个数字的字符串，默认会尽可能多地去匹配。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;b12345678A5879e123&#39;.match(/\d{3,6}/g)

&amp;gt;&amp;gt;&amp;gt;[&amp;quot;123456&amp;quot;, &amp;quot;5879&amp;quot;, &amp;quot;123&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10.2.非贪婪模式：在量词后加一个问号, 尽可能少地去匹配字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;b12345678A5879e123&#39;.match(/\d{3,6}?/g)

&amp;gt;&amp;gt;&amp;gt;[&amp;quot;123&amp;quot;, &amp;quot;456&amp;quot;, &amp;quot;587&amp;quot;, &amp;quot;123&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;11-分组&#34;&gt;11.分组：&lt;/h2&gt;

&lt;p&gt;11.1.括号“()”把字符串变成分组，使量词作用于分组。&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;abcabcabccc&#39;.match(/abc{3}/g); 
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;abccc&amp;quot;]

&#39;abcabcabccc&#39;.match(/(abc){3}/g);
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;abcabcabc&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.2.逻辑或：竖线 “|” 作用于分组, 可以表示选择多个分支中的一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;whatwhaowho&#39;.match(/wh(at|o)/g)；
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;what&amp;quot;, &amp;quot;who&amp;quot;]

&#39;whatwhaowhowhy&#39;.match(/wh(at|o|y)/g)
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;what&amp;quot;, &amp;quot;who&amp;quot;, &amp;quot;why&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11.3.捕获分组，反向引用&lt;/p&gt;

&lt;p&gt;想要把如下日期格式化：&lt;code&gt;2016-01-20&lt;/code&gt; =&amp;gt; &lt;code&gt;01/20/2016&lt;/code&gt;；可以这样写&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;2016-01-20&#39;.replace(/(\d{4})-(\d{2})-(\d{2})/g, &amp;quot;$2/$3/$1&amp;quot;)
&amp;gt;&amp;gt;&amp;gt;&amp;quot;01/20/2016&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$&lt;/code&gt;加上一个数字，数字对应的是分组的序号，第一个分组的内容用&lt;code&gt;$1&lt;/code&gt;来捕获，第二分组的内容用&lt;code&gt;$2&lt;/code&gt;来捕获，以此类推。&lt;/p&gt;

&lt;p&gt;11.4.忽略分组：分组内加上&lt;code&gt;?:&lt;/code&gt;表示忽略该分组，而捕获该组的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;2016-01-20&#39;.replace(/(?:\d{4})-(\d{2})-(\d{2})/g, &amp;quot;$1/$2&amp;quot;)
&amp;gt;&amp;gt;&amp;gt;&amp;quot;01/20&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;12-断言&#34;&gt;12.断言：&lt;/h2&gt;

&lt;p&gt;12.1.正则表达式从文本头部向文本尾部开始解析，文本尾部方向称为“前”，反之，为“后”。&lt;/p&gt;

&lt;p&gt;12.2.前瞻与后顾：正则表达式匹配到规则的时候，向前检查是否符合断言，称为&amp;rdquo;前瞻&amp;rdquo;。向后检查是否符合断言则称为&amp;rdquo;后顾&amp;rdquo;。JavaScript不支持后顾。&lt;/p&gt;

&lt;p&gt;12.3.正向/肯定前瞻：向前符合断言。exp(?=assert)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &#39;5a68cz7&#39;.match(/\d(?=[a-z])/g);
    &amp;gt;&amp;gt;&amp;gt;[&amp;quot;5&amp;quot;, &amp;quot;8&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;12.4.负向/否定前瞻：向前不符合断言。exp(?!assert)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;5a68cz7&#39;.match(/\d(?=[a-z])/g);
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;6&amp;quot;, &amp;quot;7&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;13-regexp对象属性&#34;&gt;13.RegExp对象属性&lt;/h3&gt;

&lt;p&gt;13.1.&lt;code&gt;global&lt;/code&gt;: 是否全文搜索（只读属性）;&lt;/p&gt;

&lt;p&gt;13.2.&lt;code&gt;ignoreCase&lt;/code&gt;：是否大小写敏感（只读属性）;&lt;/p&gt;

&lt;p&gt;13.3.&lt;code&gt;multline&lt;/code&gt;: 是否多行（只读属性）;&lt;/p&gt;

&lt;p&gt;13.4.&lt;code&gt;source&lt;/code&gt;：正则表达式文本内容；（只读属性）;&lt;/p&gt;

&lt;p&gt;13.5.&lt;code&gt;lastIndex&lt;/code&gt;: 当前表达式匹配内容的最后一个字符的下一个位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg1 = /\d{3,5}-\w{6}/, reg2 = /\d{3,5}-\w{6}/gim;
reg1.global
&amp;gt;&amp;gt;&amp;gt;false
reg1.ignoreCase
&amp;gt;&amp;gt;&amp;gt;false
reg1.multiline
&amp;gt;&amp;gt;&amp;gt;false
reg2.global
&amp;gt;&amp;gt;&amp;gt;true
reg2.multiline
&amp;gt;&amp;gt;&amp;gt;true
reg2.ignoreCase
&amp;gt;&amp;gt;&amp;gt;true
reg1.source
&amp;gt;&amp;gt;&amp;gt;&amp;quot;\d{3,5}-\w{6}&amp;quot;
reg2.source
&amp;gt;&amp;gt;&amp;gt;&amp;quot;\d{3,5}-\w{6}&amp;quot;
reg1.source == reg2.source
&amp;gt;&amp;gt;&amp;gt;true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;14-regexp的方法-test-exec&#34;&gt;14.RegExp的方法：&lt;code&gt;test()&lt;/code&gt;, &lt;code&gt;exec()&lt;/code&gt;;&lt;/h2&gt;

&lt;p&gt;14.1.&lt;code&gt;RegExp.test(string)&lt;/code&gt;: 测试某个字符串是否能够匹配该正则表达式。参数为字符串；返回值为布尔值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg1 = /\d/, reg2 = /\d/g;
reg1.test(&#39;a12ab&#39;);
&amp;gt;&amp;gt;&amp;gt;true

reg2.test(&#39;a12ab&#39;);
&amp;gt;&amp;gt;&amp;gt;true

reg2.test(&#39;a12ab&#39;);
&amp;gt;&amp;gt;&amp;gt;true

reg2.test(&#39;a12ab&#39;); //注意这里变成`false`了就是因为每执行一次，`lastIndex`属性变了一次导致的。所以用`test`方法的RegExp不要用全局匹配模式。
&amp;gt;&amp;gt;&amp;gt;false

reg2.test(&#39;a12ab&#39;);
&amp;gt;&amp;gt;&amp;gt;true

reg2.test(&#39;a12ab&#39;);
&amp;gt;&amp;gt;&amp;gt;true

while(reg2.test(&#39;a12ab&#39;)){
    console.log(&#39;reg2.lastIndex:&#39; +reg2.lastIndex);
}
&amp;gt;&amp;gt;&amp;gt; reg2.lastIndex:2
&amp;gt;&amp;gt;&amp;gt; reg2.lastIndex:3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;14.2.&lt;code&gt;RegExp.exec(string)&lt;/code&gt;: 返回匹配信息的数组。&lt;/p&gt;

&lt;p&gt;如果没有匹配的文本，则返回&lt;code&gt;null&lt;/code&gt;，否则返回一个结果数组。非全局匹配模式，&lt;code&gt;lastIndex&lt;/code&gt;为0，不会变。全局模式下，每次执行，&lt;code&gt;lastIndex&lt;/code&gt;都会跟着改变。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg1 = /\d+(\w)\d/, reg2 = /\d+(\w)\d/g, str=&amp;quot;1a2ce58g79ht&amp;quot;;
var result = reg1.exec(str);
console.log(reg1.lastIndex + &#39;\t&#39; + result.index+ &#39;\t&#39; + result.toString());
&amp;gt;&amp;gt;&amp;gt; 0   0   1a2,a
while(result=reg2.exec(str)){
    console.log(&#39;reg2.lastIndex:&#39;+ reg2.lastIndex + &#39;\t&#39; + &#39;result.index:&#39;+ result.index+ &#39;\t&#39; + result.toString());    
}
&amp;gt;&amp;gt;&amp;gt;reg2.lastIndex:3 result.index:0  1a2,a
&amp;gt;&amp;gt;&amp;gt;reg2.lastIndex:9 result.index:5  58g7,g
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;15-string-的一些正则操作-查找-替换-切分等-方法-match-search-replace-split&#34;&gt;15.&lt;code&gt;String&lt;/code&gt;的一些正则操作(查找、替换、切分等)方法：&lt;code&gt;match()&lt;/code&gt;、&lt;code&gt;search()&lt;/code&gt;、&lt;code&gt;replace()&lt;/code&gt;、&lt;code&gt;split()&lt;/code&gt;;&lt;/h2&gt;

&lt;p&gt;15.1. &lt;code&gt;string.match(RegExp)&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;1)非全局模式下，返回第一个匹配结果及其&lt;code&gt;index&lt;/code&gt;以及原字符串的引用(见示例代码)；&lt;/p&gt;

&lt;p&gt;2)全局模式下，返回所有匹配结果为元素的数组；&lt;/p&gt;

&lt;p&gt;3)匹配失败则返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var reg1 = /\d{4}-\d{2}-\d{2}/;
var reg2 = /\d{4}-\d{2}-\d{2}/g;
var str = &amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;;
var matchArray1 = str.match(reg1);
var matchArray2 = str.match(reg2);
console.log(matchArray1);
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;2016-10-01&amp;quot;, index: 0, input: &amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;]

console.log(matchArray2);
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;2016-10-01&amp;quot;, &amp;quot;2017-10-01&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15.2.&lt;code&gt;string.search(RegExp)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;参数可以是&lt;code&gt;子字符串&lt;/code&gt;也可以是&lt;code&gt;正则表达式&lt;/code&gt;。这个方法用来寻找某个子字符串或者正则表达式在该字符串中第一次匹配成功的位置，如果不成功，则返回&lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;15.3.&lt;code&gt;string.replace(RegExp, replacement)&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;1)这个方法用来进行正则表达式替换，将&lt;code&gt;RegExp&lt;/code&gt;能匹配的文本替换成第二个参数&lt;code&gt;replacement&lt;/code&gt;。默认只进行一次匹配。如果设定为全局模式，则所有能匹配的文本都会替换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;.replace(/\d{4}-\d{2}-\d{2}/, &amp;quot;Date&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;Date 2017-10-01 20181001&amp;quot;

&amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;.replace(/\d{4}-\d{2}-\d{2}/g, &amp;quot;Date&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;Date Date 20181001&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2)如果第二个参数字符串中引用分组，可以使用&lt;code&gt;$1&lt;/code&gt;表示第一个分组，&lt;code&gt;$2&lt;/code&gt;表示第二个分组，以此类推。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;.replace(/(\d{4})-(\d{2})-(\d{2})/, &amp;quot;$2/$3/$1&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;10/01/2016 2017-10-01 20181001&amp;quot;

&amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;.replace(/(\d{4})-(\d{2})-(\d{2})/g, &amp;quot;$2/$3/$1&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;10/01/2016 10/01/2017 20181001&amp;quot;

&amp;quot;2016-10-01 2017-10-01 20181001&amp;quot;.replace(/(\d{4})-?(\d{2})-?(\d{2})/g, &amp;quot;$2/$3/$1&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;10/01/2016 10/01/2017 10/01/2018&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3)如果要在第二个参数中表示&lt;code&gt;$&lt;/code&gt;字符，则必须使用&lt;code&gt;$$&lt;/code&gt;转义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;the price is 12.99&amp;quot;.replace(/([\d+\.\d{0,2}|\d+])/, &amp;quot;$$$1&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;the price is $12.99&amp;quot;

&amp;quot;the price is 12&amp;quot;.replace(/([\d+\.\d{0,2}|\d+])/, &amp;quot;$$$1&amp;quot;);
&amp;quot;the price is $12&amp;quot;

&amp;quot;the price is 12.99&amp;quot;.replace(/(\d+\.\d{0,2})/, &amp;quot;￥$1&amp;quot;);
&amp;gt;&amp;gt;&amp;gt;&amp;quot;the price is ￥12.99&amp;quot;

&amp;quot;the price is 12&amp;quot;.replace(/([\d+\.\d{0,2}|\d+])/, &amp;quot;$&amp;quot;);
&amp;quot;the price is $12&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4)第二个参数还可以是函数。&lt;/p&gt;

&lt;p&gt;下面的例子展示了如何将t开头的单词转换为大写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;one two three&amp;quot;.replace(/\bt[a-zA-Z]+\b/g, function(m){
    return m.toUpperCase();
});
&amp;gt;&amp;gt;&amp;gt;&amp;quot;one TWO THREE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15.4. &lt;code&gt;string.split(RegExp)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;这个方法使用一个正则表达式切分字符串，正则表达式是否使用了全局模式对结果没有影响。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;one two three&amp;quot;.split(/s+/);
&amp;gt;&amp;gt;&amp;gt;[&amp;quot;one two three&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>推荐几个常用的CDN公共库</title>
      <link>http://www.wangxingfeng.com/cdn</link>
      <pubDate>Sat, 20 Aug 2016 21:07:46 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/cdn</guid>
      <description>

&lt;h2 id=&#34;cdn&#34;&gt;CDN&lt;/h2&gt;

&lt;p&gt;CDN的全称是Content Delivery Network，即内容分发网络。是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。&lt;/p&gt;

&lt;h2 id=&#34;cdn公共库&#34;&gt;CDN公共库&lt;/h2&gt;

&lt;p&gt;CDN公共库指将常用的js库存放在CDN节点，以方便广大开发者直接调用。与存放在服务器单机上相比，CDN公共库更加稳定、高速。一般的CDN公共库都会包含全球所有最流行的开源JavaScript库，可以直接引用。&lt;/p&gt;

&lt;h3 id=&#34;优点&#34;&gt;优点：&lt;/h3&gt;

&lt;p&gt;1.提高访问速度：&lt;/p&gt;

&lt;p&gt;假设你网站的jQuery引用了新浪的CDN，那么当用户的浏览器提交请求时，浏览器自动下载网络上最近的可用的文件，下载速度会更快。&lt;/p&gt;

&lt;p&gt;2.更好的缓存:&lt;/p&gt;

&lt;p&gt;许多网站都使用了国内或者是国外的几个知名的CDN公共库。很可能用户浏览器的缓存区里早就已经下载了许多版本的jQuery，访问你的网站时，不需要重复下载jQuery。如果你用自己的服务器提供jQuery，那么你的用户至少要下载一次它。&lt;/p&gt;

&lt;h2 id=&#34;推荐几个常用前端公共库cdn&#34;&gt;推荐几个常用前端公共库CDN&lt;/h2&gt;

&lt;h3 id=&#34;国外的&#34;&gt;国外的&lt;/h3&gt;

&lt;p&gt;1.jQuery: &lt;a href=&#34;https://code.jquery.com/&#34;&gt;https://code.jquery.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.Google: &lt;a href=&#34;https://developers.google.com/speed/libraries/&#34;&gt;https://developers.google.com/speed/libraries/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.CDNJS: &lt;a href=&#34;https://cdnjs.com/libraries&#34;&gt;https://cdnjs.com/libraries&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;国内的&#34;&gt;国内的&lt;/h3&gt;

&lt;p&gt;1.cdnjs: &lt;a href=&#34;http://cdnjs.net/&#34;&gt;http://cdnjs.net/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.百度：&lt;a href=&#34;http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs&#34;&gt;http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.360：&lt;a href=&#34;http://libs.useso.com/&#34;&gt;http://libs.useso.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.又拍云：&lt;a href=&#34;http://upcdn.b0.upaiyun.com/&#34;&gt;http://upcdn.b0.upaiyun.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.新浪：&lt;a href=&#34;http://lib.sinaapp.com/&#34;&gt;http://lib.sinaapp.com/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;国内外常用的jquerycdn&#34;&gt;国内外常用的jQueryCDN：&lt;/h3&gt;

&lt;p&gt;1.jQuery官网： &lt;a href=&#34;http://code.jquery.com/jquery-2.0.0.min.js&#34;&gt;http://code.jquery.com/jquery-2.0.0.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.CDNJS： &lt;a href=&#34;http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&#34;&gt;http://cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.Google Hosted Libraries： &lt;a href=&#34;http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&#34;&gt;http://ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4.jsDeliver： &lt;a href=&#34;http://cdn.jsdelivr.net/jquery/2.0.0/jquery-2.0.0.min.js&#34;&gt;http://cdn.jsdelivr.net/jquery/2.0.0/jquery-2.0.0.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5.七牛: &lt;a href=&#34;http://cdn.staticfile.org/jquery/2.0.0/jquery.min.js&#34;&gt;http://cdn.staticfile.org/jquery/2.0.0/jquery.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6.百度: &lt;a href=&#34;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&#34;&gt;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7.新浪: &lt;a href=&#34;http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js&#34;&gt;http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;8.又拍云: &lt;a href=&#34;http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.0.min.js&#34;&gt;http://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.0.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9.360: &lt;a href=&#34;http://libs.useso.com/js/jquery/2.0.0/jquery.min.js&#34;&gt;http://libs.useso.com/js/jquery/2.0.0/jquery.min.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然，毕竟第三方的服务也不一定完全靠谱，如果引用的是国外的站点的话，哪天被墙了也有可能。所以，我们可以加入以下代码，当
CDN加载失败时，还可以加载自己本地的jQuery文件。&lt;a href=&#34;https://paulund.co.uk/fallback-on-local-jquery-if-cdn-fails&#34;&gt;以下代码来源链接&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script&amp;gt;
    window.jQuery || document.write(&#39;&amp;lt;script src=&amp;quot;js/libs/jquery-2.1.0.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&#39;);
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>前端工程师应该具备的SEO基础知识</title>
      <link>http://www.wangxingfeng.com/seo</link>
      <pubDate>Mon, 01 Aug 2016 21:49:40 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/seo</guid>
      <description>

&lt;h2 id=&#34;seo-是什么&#34;&gt;SEO 是什么？&lt;/h2&gt;

&lt;p&gt;SEO 是“Search Engine Optimization”（搜索引擎优化）或“Search Engine Optimizer”（搜索引擎优化服务商）的首字母缩略词。通俗地说，SEO就是通过对网站内部调整优化及站外优化，使网站满足搜索引擎收录排名需求，在搜索引擎中提高关键词排名，从而把精准用户带到网站，获得免费流量，产生直接销售或品牌推广。&lt;/p&gt;

&lt;p&gt;新手入门可以阅读&lt;a href=&#34;https://support.google.com/webmasters/answer/35291?hl=zh-Hans&#34;&gt;Google 搜索引擎优化 (SEO) 单页指南.pdf&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;如果想要进一步学习，可以参考&lt;a href=&#34;http://static.googleusercontent.com/media/www.google.com/en/us/intl/zh-cn/webmasters/docs/search-engine-optimization-starter-guide-zh-cn.pdf&#34;&gt;Google搜索引擎优化入门指南&lt;/a&gt; （需翻墙），&lt;a href=&#34;http://www.wangxingfeng.com/posts/search-engine-optimization-starter-guide-zh-cn.pdf&#34;&gt;如果翻不了，可以点击这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;前端工程师应该掌握的seo知识&#34;&gt;前端工程师应该掌握的SEO知识&lt;/h2&gt;

&lt;p&gt;目前不少公司设有SEO的专职岗位，而前端工程师不是专业做SEO优化推广的，并不需要变成SEO专家，但应掌握以下SEO基础知识。&lt;/p&gt;

&lt;h3 id=&#34;一-结构布局的优化&#34;&gt;一、结构布局的优化&lt;/h3&gt;

&lt;p&gt;1.结构扁平化。&lt;/p&gt;

&lt;p&gt;网站的层次结构尽量不超过三层。这样搜索引擎或者用户点击跳转3次可以到达网站内任何一个内页。&lt;/p&gt;

&lt;p&gt;2.优化导航。&lt;/p&gt;

&lt;p&gt;设置页面的主导航、副导航、分类导航、面包屑导航、分页页码等，方便用户跳转到想访问的页面。&lt;/p&gt;

&lt;h3 id=&#34;二-标签的语义化&#34;&gt;二、标签的语义化&lt;/h3&gt;

&lt;p&gt;搜索引擎的爬虫会依赖于标记来确定上下文和各个关键字的权重.因此，正确使用语义化的标签有利于搜索引擎抓取和收录网页内容。&lt;/p&gt;

&lt;p&gt;1.锚链接 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标签：&lt;/p&gt;

&lt;p&gt;1）添加属性 &lt;strong&gt;title=&amp;ldquo;链接的文字说明&amp;rdquo;&lt;/strong&gt;，增加对该链接的说明，尤其是指向本站的链接。&lt;/p&gt;

&lt;p&gt;2）添加属性 &lt;strong&gt;rel=&amp;ldquo;no follow&amp;rdquo;&lt;/strong&gt;。 对于指向非本站的链接，增加这个属性是告诉爬虫该页面无需追踪。&lt;/p&gt;

&lt;p&gt;2.正文标题用&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;,副标题用&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt;, 不要滥用标题。&lt;/p&gt;

&lt;p&gt;3.正文内容用&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;，正文内的换行用&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;， 其他地方不要滥用&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;来换行，而是通过CSS样式来设置。&lt;/p&gt;

&lt;p&gt;4.图片&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;添加属性 &lt;strong&gt;alt=&amp;ldquo;图片的文字注释&amp;rdquo;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;5.表格用&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; ，表格的标题使用 &lt;code&gt;&amp;lt;caption&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;6.有序列表用&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;， 无序列表用&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;， 定义列表用&lt;code&gt;&amp;lt; dl&amp;gt;&lt;/code&gt;、&lt;/p&gt;

&lt;p&gt;7.强调标签： &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; 表示强调， 可以用于突出关键词，有较大的权重。&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;也表示强调，权重比strong稍低。&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;标签虽然也有加粗效果，但没有强调的作用，因此不会增加标签内的文本权重。&lt;/p&gt;

&lt;p&gt;8.减少&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;的使用。iframes 阻塞页面加载, 延迟触发window.onload事件，给用户的感觉就是这个网页非常慢。&lt;/p&gt;

&lt;p&gt;9.重要内容HTML代码放在最前面，然后通过CSS属性控制位置。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title> CSS3 动画效果</title>
      <link>http://www.wangxingfeng.com/css3-%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C</link>
      <pubDate>Mon, 11 Jul 2016 21:03:27 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/css3-%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C</guid>
      <description>

&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;

&lt;p&gt;用来定义样式变化的过渡效果, 在某些情况下（移动端），可以代替JavaScript代码来实现动画效果。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transition&lt;/code&gt;属性是一个简写属性，用于设置四个过渡属性：&lt;/p&gt;

&lt;h3 id=&#34;1-transition-property&#34;&gt;1. transition-property&lt;/h3&gt;

&lt;p&gt;规定设置过渡效果的 CSS 属性的名称, 默认值为&lt;code&gt;all&lt;/code&gt;, 表示所有属性，也可以单独设置某个css属性。&lt;/p&gt;

&lt;h3 id=&#34;2-transition-duration&#34;&gt;2. transition-duration&lt;/h3&gt;

&lt;p&gt;过渡时间，值以秒或毫秒计。&lt;/p&gt;

&lt;h3 id=&#34;3-transition-timing-function&#34;&gt;3. transition-timing-function&lt;/h3&gt;

&lt;p&gt;过渡效果的速度曲线。该属性允许过渡效果随着时间来改变其速度。&lt;/p&gt;

&lt;p&gt;默认值为&lt;code&gt;linear&lt;/code&gt;。常见的有以下值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;linear  匀速
ease    慢速开始，然后变快，然后慢速结束。
ease-in 以慢速开始
ease-out    以慢速结束
ease-in-out 以慢速开始和结束的过渡效果
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-transition-delay&#34;&gt;4. transition-delay&lt;/h3&gt;

&lt;p&gt;过渡效果的延迟，值以秒或毫秒计。默认为0。如果为正值，则表示延迟执行过渡效果；如果为负值（如-0.1s)，则会从过渡效果的执行0.1s的状态为初始状态开始执行过渡效果。&lt;/p&gt;

&lt;h2 id=&#34;兼容性&#34;&gt;兼容性&lt;/h2&gt;

&lt;p&gt;Internet Explorer 10、Firefox、Opera 和 Chrome等现代浏览器 支持 transition 属性。
Safari 支持替代的 -webkit-transition 属性。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;style&gt;
 .trans {
    display:block;
    width:100px;
    height:30px;
    background:#0ff;
    transition:width 2s ease;
 }
 .trans:hover{
    width:500px;
 }
&lt;/style&gt;

&lt;p&gt;&lt;a class=&#34;trans&#34;&gt;过渡效果&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>实现Tab切换的几种方式</title>
      <link>http://www.wangxingfeng.com/tab</link>
      <pubDate>Sun, 08 May 2016 23:36:44 +0800</pubDate>
      
      <guid>http://www.wangxingfeng.com/tab</guid>
      <description>

&lt;p&gt;Tab 切换是网页中常见的组件。适当地使用，可以节省页面空间，在同一个大小的页面中展现更多的内容。Tab 切换的效果千差万别，只需要学会基本的思路，便可变换出各种各样的效果。下面我分别使用了原生js和jQuery来实现四种不同的Tab切换效果。&lt;/p&gt;

&lt;h2 id=&#34;方式一-用原生js实现各种tab切换效果&#34;&gt;方式一：用原生js实现各种Tab切换效果。&lt;/h2&gt;

&lt;h3 id=&#34;1-鼠标滑动切换&#34;&gt;1.鼠标滑动切换 :&lt;/h3&gt;

&lt;p&gt;这是最简单的Tab切换。鼠标滑过时，切换Tab.&lt;/p&gt;

&lt;p&gt;首先，通过getElementById、 getElementsByTagNameL等方法来获取相应的元素。&lt;/p&gt;

&lt;p&gt;然后，对相应的元素绑定mouseover事件即可。&lt;/p&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/js-mouseover-tab.html&#34;&gt;js-mouseover-tab.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/js-mouseover-tab.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-鼠标点击切换&#34;&gt;2.鼠标点击切换&lt;/h3&gt;

&lt;p&gt;与第一种的区别在于绑定的事件不同。获取元素的方法是一样的，只需把绑定mouseovers事件改为click事件即可。&lt;/p&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/js-click-tab.html&#34;&gt;js-click-tab.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/js-click-tab.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-鼠标滑动延迟切换&#34;&gt;3.鼠标滑动延迟切换&lt;/h3&gt;

&lt;p&gt;延迟切换涉及到了一个时间问题，可以通过设置定时器来实现延迟的效果。定时器有setTimeout()和setInterval()两种方式来设置。&lt;/p&gt;

&lt;p&gt;setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。setTimeout() 只执行 code 一次。如果要多次调用，需要使用 setInterval()。&lt;/p&gt;

&lt;p&gt;setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。&lt;/p&gt;

&lt;p&gt;因为这里的延迟切换是在指定的延迟时间之后才实现切换效果，所以使用setTimeout() 。&lt;/p&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/js-delay-tab.html&#34;&gt;js-delay-tab.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/js-delay-tab.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-自动切换&#34;&gt;4.自动切换&lt;/h3&gt;

&lt;p&gt;自动切换，即按指定的周期自动切换到下一个Tab。这里也需要一个定时器，而且是按周期调用函数，因此使用setInterval() 方法来实现。
当鼠标滑动到某个Tab时，高亮显示当前页，同时停止自动切换，此时需要用到 clearInterval()方法来清除定时器。&lt;/p&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/js-auto-tab-01.html&#34;&gt;js-auto-tab-01.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优化后的代码见 &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/js-auto-tab-02.html&#34;&gt;js-auto-tab-02.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/js-auto-tab-02.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;方式二-用jquery实现各种tab切换效果-实现思路与原生的javascript是一样的-只是jquery封装了一些方法可以更方便操作dom元素&#34;&gt;方式二：用jQuery实现各种Tab切换效果: 实现思路与原生的JavaScript是一样的,只是jQuery封装了一些方法可以更方便操作DOM元素。&lt;/h2&gt;

&lt;h3 id=&#34;1-鼠标滑动切换-1&#34;&gt;1.鼠标滑动切换&lt;/h3&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/jQ-mouseover-tab.html&#34;&gt;jQ-mouseover-tab.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/jQ-mouseover-tab.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-鼠标点击切换-1&#34;&gt;2.鼠标点击切换&lt;/h3&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/jQ-click-tab.html&#34;&gt;jQ-click-tab.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/jQ-click-tab.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;3-鼠标滑动延迟切换-1&#34;&gt;3.鼠标滑动延迟切换&lt;/h3&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/jQ-delay-tab.html&#34;&gt;jQ-delay-tab.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/jQ-delay-tab.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-自动切换-1&#34;&gt;4.自动切换&lt;/h3&gt;

&lt;p&gt;具体代码见  &lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/jQ-auto-tab-01.html&#34;&gt;jQ-auto-tab-01.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优化后的代码 见&lt;a href=&#34;https://github.com/frankwang0909/Tab/blob/master/jQ-auto-tab-02.html&#34;&gt;jQ-auto-tab-02.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wangxingfeng.com/posts/demo/jQ-auto-tab-02.html&#34;&gt;DEMO&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>